// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: sessions.sql

package dbc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const clearOtherSessions = `-- name: ClearOtherSessions :exec
delete from sessions as s using users as u
where s.user_pk = u.pk
	and s.id != $1
	and u.id = $2
`

type ClearOtherSessionsParams struct {
	SessionId uuid.UUID `json:"sessionId"`
	UserId    uuid.UUID `json:"userId"`
}

func (q *Queries) ClearOtherSessions(ctx context.Context, arg ClearOtherSessionsParams) error {
	_, err := q.db.Exec(ctx, clearOtherSessions, arg.SessionId, arg.UserId)
	return err
}

const createSession = `-- name: CreateSession :one
insert into sessions(token, user_pk, device)
	values ($1, $2, $3)
returning
	pk, id, token, user_pk, created_date, last_used, device
`

type CreateSessionParams struct {
	Token  string  `json:"token"`
	UserPk int32   `json:"userPk"`
	Device *string `json:"device"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession, arg.Token, arg.UserPk, arg.Device)
	var i Session
	err := row.Scan(
		&i.Pk,
		&i.Id,
		&i.Token,
		&i.UserPk,
		&i.CreatedDate,
		&i.LastUsed,
		&i.Device,
	)
	return i, err
}

const deleteSession = `-- name: DeleteSession :one
delete from sessions as s using users as u
where s.user_pk = u.pk
	and s.id = $1
	and u.id = $2
returning
	s.pk, s.id, s.token, s.user_pk, s.created_date, s.last_used, s.device
`

type DeleteSessionParams struct {
	Id     uuid.UUID `json:"id"`
	UserId uuid.UUID `json:"userId"`
}

func (q *Queries) DeleteSession(ctx context.Context, arg DeleteSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, deleteSession, arg.Id, arg.UserId)
	var i Session
	err := row.Scan(
		&i.Pk,
		&i.Id,
		&i.Token,
		&i.UserPk,
		&i.CreatedDate,
		&i.LastUsed,
		&i.Device,
	)
	return i, err
}

const getUserFromToken = `-- name: GetUserFromToken :one
select
	s.pk,
	s.id,
	s.last_used,
	u.pk, u.id, u.username, u.email, u.password, u.claims, u.created_date, u.last_seen
from
	users as u
	inner join sessions as s on u.pk = s.user_pk
where
	s.token = $1
limit 1
`

type GetUserFromTokenRow struct {
	Pk       int32     `json:"pk"`
	Id       uuid.UUID `json:"id"`
	LastUsed time.Time `json:"lastUsed"`
	User     User      `json:"user"`
}

func (q *Queries) GetUserFromToken(ctx context.Context, token string) (GetUserFromTokenRow, error) {
	row := q.db.QueryRow(ctx, getUserFromToken, token)
	var i GetUserFromTokenRow
	err := row.Scan(
		&i.Pk,
		&i.Id,
		&i.LastUsed,
		&i.User.Pk,
		&i.User.Id,
		&i.User.Username,
		&i.User.Email,
		&i.User.Password,
		&i.User.Claims,
		&i.User.CreatedDate,
		&i.User.LastSeen,
	)
	return i, err
}

const getUserSessions = `-- name: GetUserSessions :many
select
	s.pk, s.id, s.token, s.user_pk, s.created_date, s.last_used, s.device
from
	sessions as s
	inner join users as u on u.pk = s.user_pk
where
	u.pk = $1
order by
	last_used
`

func (q *Queries) GetUserSessions(ctx context.Context, pk int32) ([]Session, error) {
	rows, err := q.db.Query(ctx, getUserSessions, pk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.Pk,
			&i.Id,
			&i.Token,
			&i.UserPk,
			&i.CreatedDate,
			&i.LastUsed,
			&i.Device,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const touchSession = `-- name: TouchSession :exec
update
	sessions
set
	last_used = now()::timestamptz
where
	pk = $1
`

func (q *Queries) TouchSession(ctx context.Context, pk int32) error {
	_, err := q.db.Exec(ctx, touchSession, pk)
	return err
}
